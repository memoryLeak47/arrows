# overview

tickEntities():
	dynamic_entities.tick()
	dynamic_entities.changed = true

GameInterface::tick():
	tickEntities()
	tickPhysics()

tickPhysics():
	updateChanged()
	while (events.size() > 0):
		moveTo(next_event)
		addPartners(next_event.entities)
		updateChanged()
		# check loop limit
	move to end of frame

updateChanged():	
	for (e1 : dynamic_entities):
		for (e2 : dynamic_entities > e1):
			if (areCollisionPartners(e1, e2))
				continue
			if (e1->hasChanged() or e2->hasChanged()):
				update(e1, e2)
		if (e1->hasChanged()):
			for (tile : e1.intersectionTiles())
				if (areCollisionPartners(e1, tile))
					continue
				update(e1, *iter, events, timeLeft);
		for (c : collisionpartners):
			update(e1, c)

	dynamic_entities.changed = false

update(e1, e2):
	if (partners(e1, e2)):
		if (exitCheck(e1, e2))
			remove partners(e1, e2)
			detect events between(e1, e2)
		else
			handlePhysics(e1, e2)
	else
		delete events between(e1, e2)
		detect events between(e1, e2)

handlePhysics(e1, e2):
	handleRecursive(e1)

handleRecursive(e):
	for (c : e->partners):
		if (moveToEachOther(e, c, getEsc(e, getCollisionPoints(e, c)))):
			applyPhysics(e, c)
			handleRecursive(c)

getCollisionPoints(e1, e2):
	if (even-rects): # XXX INSTANCEOF XXX
		x1 = max(e1.left, e2.left)
		x2 = min(e1.right, e2.right)

		y1 = max(e1.top, e2.top)
		y2 = min(e1.bot, e2.bot)

		lefttop = {min(x1, x2), min(y1, y2)}
		rightbot = {max(x1, x2), max(y1, y2)}
		if (lefttop == rightbot): # TODO shouldn't be ==
			return {lefttop}
		return {lefttop, rightbot}

getEsc(e, points):
	if (points.size == 2):
		ab = points[1] - points[0]
		am = e.pos - points[0]
		res = am.getProjectionOn(ab.getOrthogonal())
		if (result.getMagnitude() == 0)
			throw ERROR
		v = (-res).getNormalized()
                if (abs(v.x) > abs(v.y)): # even-rects workaround
                        if (v.x<0):
                                return {-1, 0}
                        return {1,0}
                if (v.y<0):
                        return {0,-1}
                return {0,1}

	if (points.size == 1):
		if (e.pos.x < points[0].x):
			return {1, 0}
		else if (e.pos.x > points[0].x)
			return {-1, 0}
		else
			throw ERROR

moveToEachOther(e1, e2, esc):
	return 0 < scalar(esc, e1.speed - e2.speed)

applyPhysics(e1, e2):
	m1 = e1.mass
	m2 = e2.mass

	v_sum = (0, 0)
	if (no tile)
		v_sum = ((e1->getBody()->getSpeed()*m1)+(e2->getBody()->getSpeed()*m2)) / (m1+m2)

	points = getCollisionPoints(e1, e2)
	esc = getEscapeVector(e1, points)
	otto = esc.getOrthogonal()

	if (not moveToEachOther(e1, e2, esc))
		return

	e1.speed = e1.speed.getProjectionOn(otto)*(1-DRAG) + v_sum.getProjectionOn(esc) - esc.withMagnitude(SPONGE)
	e2.speed = e2.speed.getProjectionOn(otto)*(1-DRAG) + v_sum.getProjectionOn(esc) + esc.withMagnitude(SPONGE)
