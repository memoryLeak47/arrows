# GameInterfaceTick()

# TODO:
# what about gravity?

static float GameInterface::MAX_TIME = 1;

void GameInterface::tick()
{
	// TODO receive() & send()
	tickEntities();
	tickPhysics();
	render();
}

void GameInterface::tickEntities()
{
	for dynamic-entity: tick();
}

void GameInterface::tickPhysics()
{
	float timeLeft = MAX_TIME;
	std::vector<Collision*> collisions;
	addAllCollisions(&collisions); // Errechnet alle Collisions, die in diesem Frame passieren würden, wenn sich die zugehörigen Entities mit konstanter Geschwindigkeit bewegen würden
	while (collisions.size() > 0)
	{
		Collision* c = getFirstCollision(collisions); // Returnt die Collision mit kleinstem getTime(). Also die Collision, die als nächstes ausgeführt werden muss.
		moveAllEntities(c->getTime()); // bewegt alle Entities bis zu der Situation, in der die nächste "globale" Collision passiert
						   // TODO remember rotation is updated too
		timeLeft -= c->getTime();

		// Reaktion auf die Collision
		// Falls eine der Entities beschleunigt wurde, werden die Collisions der Entity neu berechnet (Die alten werden gelöscht)(auch beide Entities können betroffen sein)
		// Die Collision, auf die gerade reagiert wurde, wird auf alle Fälle gelöscht, auch wenn keine der beiden Entities 
		applyCollision(c, collisions, timeLeft);
	}
	moveAllEntities(timeLeft);
}

void GameInterface::addAllCollisions(std::vector<Collision*>* collisions)
{
	for entity as non-tile-entity: addCollisionsFrom(entity, collisions, MAX_TIME);
}

void GameInterface::addCollisionsFrom(Entity* e, std::vector<Collision*>* collisions, float timeLeft)
{
	for entity in entities
	{
		if (e != entity && e->getCollisionPriority(entity) + entity->getCollisionPriority(e) >= 0 && collision doesnt exist)
		{
			Collision *c = CollisionDetector::getCollisionBetween(entity, e, timeLeft);
			if (c != NULL)
			{
				collisions->push_back(c);
			}
		}
	}
}

void GameInterface::applyCollision(Collision* c, std::vector<Collision*>* collisions, float timeLeft)
{
	// Collision wird aus Liste entfernt
	EntferneDieCollisionAusListe(c, collisions);
	// Beide Entities reagieren auf die Collision
	for e in c->getEntities()
	{
		// Collisions neu berechnen, wenn eine der Entities beschleunigt wurde
		if (e.applyCollision(c))
		{
			LöscheAlleCollisionsMit(e);
			addCollisionsFrom(e, collisions, timeLeft);
		}
	}
	delete c;
}

Collision* CollisionDetector::getCollisionBetween(Entity*, Entity*, float timeLeft)
{
	// Ansätze für diese Funktion finden sich in collisionDetection/
}

void Entity::applyCollision(Collision* c)
{
	// TODO

	/* Grober Plan:
		sponginess := max(sponginess1, sponginess2)
		v1 := (m1*v1 + m2*v2)/(m1 + m2)*(1 + sponginess) // Funktioniert für sticky-collision
		v2 := (m1*v1 + m2*v2)/(m1 + m2)*(1 - sponginess)

		CollisionHandlingTypes:
		- solid { float sponginess; }
		- permeable

		- bool Entity::isStatic()
		- CollisionHandlingType* Entity::collisionHandlingType;
		- GameVector Entity::push(GameVector speed, GameVector point, float/int mass)
			Falls zwei solid-Objekte sich berühren, ruft entity1 folgendes auf: otherEntity->push(this->speed, collisionPoint, this->mass)
			die push()-Funktion wird rekursiv ausgeführt
			die push()-Funktion returnt die Geschwindigkeit die das aufrufende Objekt nach der Kollision bekommt

			Beispiel:

				  | // arrow A
				  V
				[""] // Kiste B
				["""""] // static-tile C

				A fällt von oben in B
				A führt deshalb
					B->push(this->speed, collisionPoint, this->mass) aus.
				B::push(speed, collisionPoint, mass) leitet push weiter, führt also
					C->push(speed + this->speed, collisionPointToC, mass + this->mass) aus.
				C::push(speed, collisionPoint, mass)
					returnt GameVector(0,0), da es ein static-tile ist
				B::push gibt GameVector(0,0) zurück.
				deshalb: B->speed = GameVector(0,0)
				A::push gibt GameVector(0,0) zurück.
				deshalb: A->speed = GameVector(0,0)
	*/
}
